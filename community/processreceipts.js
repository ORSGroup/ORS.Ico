// ----------------------------------------------------------------------------
// Read Receipts from a text file generated by cli.js and the shell
//
// For each receipt:
//
//    a. if we are below the block lower limit then skip this receipt
//    b. confirm sender is on eidoo's amlkyc list. if not, add to refund list
//       and skip this receipt
//    c. calculate the number of tokens bought at 0.05/token
//    d. apply the Community bonus (10%)
//    e. read eidoo list and determine whether sender was using eidoo wallet.
//       if so add 5% bonus
//
// ----------------------------------------------------------------------------

const fs = require('fs');
const Web3 = require('web3');
const web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));

const ORST_SCA = '0x...'; // TODO: replace with ORST token SCA

const bigInt = require( 'big-integer' );
const https = require( 'https' );
const rdr = require( 'readline' );

const fname = 'sortedreceipts.txt';
//const ename = 'eidoo_addresses_20180409.csv';
const ename = 'eidoo_addresses_20180427.txt'

// https://eidoo-api-1.eidoo.io/api/ico/<addr>/authorization/<addr>

const authurl1 = 'https://eidoo-api-1.eidoo.io/api/ico/';
const authurl2 = '/authorization/';

const lowerLimit = parseInt( process.argv[2] );
const MYGASPRICE = '' + 1 * 1e9; // 1 Gwei

function getABI() {
  return JSON.parse(
    fs.readFileSync('../ors/build/MineableToken_sol_MineableToken.abi')
	    .toString() );
}

var eidusers = {}; // "address" : "true"

function readEidooWalletFile() {
  console.log( 'readEidooWalletFile' );

  let reader = rdr.createInterface( { input: fs.createReadStream(ename) } );

  reader.on('line', function(line) {
    let parts = line.split( /\s+/ );
    eidusers[parts[0]] = "true";
  } )
  .on('close', () => {
    console.log( 'done reading ' +
                 Object.keys(eidusers).length +
                 ' eidoo wallet users.' );
  } );
}

function isEidooWallet( addr ) {
  return ( eidusers[addr] == "true" );
}

//let con = new web3.eth.Contract( getABI(), ORST_SCA );

var etheur = 409.70; // use hardcoded rate provided
var receipts = []; // raw
var distribs = [];
var refunds = [];
var sumwei = bigInt();

function readReceiptFile() {

  console.log( 'readReceiptFile' );

  let reader = rdr.createInterface( { input: fs.createReadStream(fname) } );

  reader.on('line', function(line) {
    let parts = line.split( /\s+/ );

    let receipt = {};
    receipt['number'] = parseInt( parts[0] );
    receipt['sender'] = '' + parts[1];
    receipt['weisent'] = bigInt( parts[2] );
    receipt['block'] = parseInt( parts[3] );
    receipt['community'] = '' + parts[4];

    sumwei += receipt['weisent'];

    receipts.push( receipt );
  } )
  .on('close', () => {
    console.log( 'sum (ETH): ', sumwei / bigInt('1e18') );
    processReceipts();
  } );
}

function registrationStep( rcpt ) {
  https.get( authurl1 + rcpt['sender'] + authurl2 + rcpt['sender'], rsp => {
    rsp.setEncoding( "utf8" );
    let body = "";

    rsp.on( "data", data => {
      body += data;
    } )
    .on( "end", () => {
      body = JSON.parse(body);
      console.log( rcpt['sender'] + ' ' +
                   rcpt['weisent'] + ' ' +
                   body['authorized'] );

      rcpt['authorized'] = body['authorized'];

      if (rcpt['authorized']) {
        distribs.push( rcpt );
      }
      else {
        refunds.push( rcpt );
      }
    } );
  } );
}

function processReceipts() {

  // 0.05 cents per token means 20 tokens to the EUR
  const tokpereth = etheur * 20;

  for (let ii = 0; ii < receipts.length; ii++) {

    if ( (ii+1) < lowerLimit)
      continue; // cat -n starts at 1, not 0

    setTimeout( () => {
      registrationStep( receipts[ii] );
    }, 20000 * Math.random() );
  };

  //
  // runs after the registrationStep calls have all returned
  //
  setTimeout( () => {

    console.log( '# receipts: ' + receipts.length );
    console.log( '# distribs: ' + distribs.length );
    console.log( '# refunds: ' + refunds.length );

    console.log( 'DISTRIBS: ' + distribs.length );

    let sumtokens = bigInt(0);

    for (let ii = 0; ii < distribs.length; ii++) {

      let bonus = 0;

      if (isEidooWallet(distribs[ii]['sender']))
        bonus += 5;

      // for now, all communities are the same
      //
      // TODO : fetch from blockchain instead
      bonus += 10;

      // -------------------------------------------------------
      // Quantity of tokens calculation
      //
      // Q = (ethersent * tokpereth) * (100 + bonus)/100
      //   = (wei/10**18 * tokpereth) * (100+bonus)/100
      //
      // -------------------------------------------------------

      let qty = distribs[ii]['weisent'] * tokpereth * (100+bonus)/100;

      // mine the tokens for the sale, leaves them in the caller's account
      // NOTE: caller must be the owner of the token smart contract to work

      console.log( distribs[ii]['sender'] + ' ' + qty );

      sumtokens += qty;
    }

    console.log( 'total tokens: ' + sumtokens );
  }, 25000 );

  setTimeout( () => {

    console.log( 'REFUNDS (wei): ' + refunds.length );
    let refsum = 0;

    for (let jj = 0; jj < refunds.length; jj++) {
      console.log( refunds[jj]['sender'] + ' ' + refunds[jj]['weisent'] );
      refsum += refunds[jj]['weisent'];
    }

    console.log( 'sum (wei): ' + refsum );
  }, 35000 );
}

//  con.mine( qty )
//    .send( {from: web3.eth.accounts[6], gas: 64000, gasPrice: MYGASPRICE} );
//    .then( () => {

// transfer the tokens from caller's account to sender

//    con.transfer( distribs[ii]['sender'], qty )
//       .send( {from: web3.eth.accounts[6],
//               gas: 70000,
//               gasPrice: MYGASPRICE} );

//  });

//  web3.eth.sendTransaction( {from: web3.eth.accounts[6],
//                             to: refunds[ii]['sender'],
//                             gas: 22000,
//                             gasPrice: MYGASPRICE} );

readEidooWalletFile();
readReceiptFile();
